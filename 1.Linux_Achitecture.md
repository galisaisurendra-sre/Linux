## 1.Linux System Architecture Overview

```
Linux is designed in a layered architecture, where each layer has a specific role.

```

#### 1.1 Hardware (Bottom Layer)

This is the physical layer ‚Äî CPU, memory, disk, network card, etc.
It‚Äôs what Linux runs on and manages.

Examples: CPU cores, RAM, SSD/HDD, network interfaces (eth0, wlan0)

### 1.2. Kernel

The core of Linux ‚Äî acts as a bridge between hardware and software.
It handles:

Process management (running programs)

Memory management

Device drivers

Networking

System calls

üß† Think of it as the brain of the OS.

### 1.3.System Libraries

These are helper programs that let user applications talk to the kernel easily without dealing with low-level hardware.
Example: glibc ‚Äî the GNU C Library, used by almost every program.

üîπ Functions like reading files, printing text, or allocating memory use these libraries.

### 1.4. User Applications

Everything you interact with: commands, shells, GUIs, and services.

Shells: bash, zsh, fish

Editors: vim, nano

Servers: nginx, sshd

Desktop environments: GNOME, KDE

## Flow of Interaction

```
User ‚Üí Shell ‚Üí System Libraries ‚Üí Kernel ‚Üí Hardware

**When you type a command like:**

ls /home

**This happens:**

The shell takes your command.

It calls the system libraries to request a directory listing.

The kernel fetches data from the disk hardware.

Output flows back up to your screen


+-------------------------+
|  User Applications      |  ‚Üê Your apps (bash, vim, nginx, etc.)
+-------------------------+
|  System Libraries       |  ‚Üê APIs that talk to kernel
|  & System Utilities     |  ‚Üê Commands like ls, cp, cat
+-------------------------+
|  Kernel (Linux)         |  ‚Üê OS core: manages CPU, memory, devices
+-------------------------+
|  Hardware               |  ‚Üê Physical machine
+-------------------------+

```

## Why We Need a Shell in Linux

A shell is needed because it acts as the **bridge between you (the user) and the Linux kernel (the core of the operating system).**

The kernel can‚Äôt directly understand human input ‚Äî it understands system calls, not words.
The shell translates your commands into something the kernel can execute.
